# DB Audit — Salon SaaS (public schema)

This working doc tracks findings and decisions while we audit and refine your **public** schema. We’ll keep it lean and MVP‑first.

---

## Phase Plan

1. Inventory (tables, columns, keys, FKs, indexes, RLS, triggers, views)
2. Naming & modeling lint (pluralization, snake_case, tenant scope)
3. Security pass (RLS coverage, force RLS where appropriate)
4. Performance pass (indexes, partials, uniques)
5. Plan‑gating (Starter vs. Professional tables/policies)
6. Final summary (hand‑off brief for Claude)

---

## Findings (paste results + notes)

**Inventory (public):**

* Tables (RLS ✅/❌):

  * ✅ appointments, audit_logs, customer_accounts, customer_notes, customer_tags, customers, features, invitations, memberships, plan_features, plan_tiers, plans, profiles, services, staff, subscriptions, tenants, webhook_events
  * ❌ ops_events (RLS off) → candidate for `internal` schema or strict RLS
* Views:

  * `active_subscriptions` (used for access gating), `tier_features` (read layer for plans)

**Notable observations (Q1–Q9):**

* `ops_events` has **no tenant_id** and **RLS disabled** → public exposure risk; should be internal or fully locked.
* `appointments`: has `time_range (tstzrange)` and **two GiST indexes** (`idx_appointments_staff_time`, `no_overlap_per_staff`) but **no EXCLUDE constraint**. We recommend **one** exclusion constraint using an expression to skip non-active statuses.
* `customers.email` is **CITEXT** (good). `customers.total_spent` is **INTEGER (cents)** while `appointments.total_price` and `services.price` are **NUMERIC** → **money-type mismatch** handled via new `appointments.total_amount_cents`.
* `profiles.id → auth.users(id)` FK **exists** (good).
* `customer_accounts`: present with RLS; add tenant consistency & prevent tenant move triggers (hardening).
* `tenants.slug` is unique (ok). Keep as public lookup key.
* `subscriptions`: strong indexing incl. partial unique for one active per tenant (good). Service-role policies present.
* RLS (Q7): many **duplicate/overlapping policies**, inconsistent `{public}` vs `{authenticated}`, mixed case in role checks, and heavy JOINs for Pro-gates. We will **consolidate** per table and rely on `active_subscriptions` view.

---

## Proposed Changes (draft)

### Security & Access

1. **`ops_events`**: move to `internal` schema *or* enable RLS and expose nothing to app roles.
2. **RLS consolidation**: Replace many `{public}` policies with a **minimal, consistent set** (`TO authenticated`, plus explicit `service_role` only where needed). Use `lower(role)` for admin checks, and the same tenant/access predicate everywhere.
3. **audit_logs**: set `actor_id` FK to **ON DELETE SET NULL**.
4. **appointments.cancelled_by**: set FK to **ON DELETE SET NULL**.
5. **memberships**: keep **read-only (own)** in SQL; handle write ops via RPC/service role (prevents privilege escalation).

### Data Integrity

6. **Appointments no-overlap**: add **EXCLUDE USING gist** on `(tenant_id, staff_id, CASE WHEN status IN ('SCHEDULED','CONFIRMED','IN_PROGRESS') THEN time_range END WITH &&)` and drop redundant GiST indexes.
7. **Money alignment**: keep `appointments.total_amount_cents INT` alongside NUMERIC; adjust stats trigger to use cents.
8. **appointments.customer_id FK**: add FK to `customers(id)` + same-tenant trigger.
9. **customer_accounts**: add same-tenant trigger + prevent `tenant_id` updates.

### Index/Perf

10. Replace `idx_appointments_time (start_time, end_time)` with `(tenant_id, start_time DESC)`; the exclusion constraint supplies the GiST.
11. Keep `customers` GIN (`search_tsv`) and partial uniques `(tenant_id, email/phone)`.

### Naming/Lint

12. **`ops_events`** → rename to `event_outbox` if kept; document as internal/outbox.
13. Document `active_subscriptions`, `tier_features` as read-layer; use them in RLS predicates.

---

## Change Log (running)

* [SEC] Flagged `ops_events` (RLS off, no tenant_id). Decision: move to `internal` schema or hard‑lock via RLS; consolidate created_at indexes.
* [RLS] Plan to **drop all duplicate `{public}` policies** on appointments/services/staff/customers/invitations/tenants/subscriptions and recreate **4 clean policies** each for `authenticated` (+ service_role where explicitly needed).
* [SEC] `audit_logs.actor_id` → switch FK to **ON DELETE SET NULL**.
* [SEC] `appointments.cancelled_by` → switch FK to **ON DELETE SET NULL**.
* [INT] Add FK `appointments.customer_id → customers(id)` + same‑tenant enforcement trigger.
* [INT] Add exclusion constraint on `appointments(tenant_id, staff_id, active_time_range)`; drop GiST duplicates; add `(tenant_id, start_time DESC)` btree.
* [INT] Money alignment: keep & use `appointments.total_amount_cents`; adjust `update_customer_stats()` accordingly.
* [SEC] `customer_accounts` tenant hardening triggers (same‑tenant + prevent tenant moves).
* [GOV] `memberships` write paths to RPC/service‑role only; SQL RLS stays read‑only for end users.
* [DOC] Views `active_subscriptions`, `tier_features` confirmed; will be used in RLS for Pro gating.

---

## Claude Hand-off

### Executive summary

* Konsolidiert die RLS-Landschaft auf **klare, konsistente Policies** pro Tabelle (SELECT/INSERT/UPDATE/DELETE) ausschließlich für **`authenticated`**; `service_role` nur gezielt (Subscriptions/Webhooks). `{public}`-Policies werden entfernt.
* Schließt Integritätslücken: FK `appointments.customer_id → customers(id)` inkl. **Same‑Tenant‑Enforcement**; **ON DELETE SET NULL** bei `audit_logs.actor_id` und `appointments.cancelled_by`.
* Verhindert Termin-Überlappungen per **EXCLUDE USING gist** (status‑sensitiv) und bereinigt doppelte GiST‑Indizes.
* Vereinheitlicht Geldflüsse: führt **`appointments.total_amount_cents INT`** und aktualisiert den **Stats‑Trigger** zur Verwendung von Cents.
* Härtet `customer_accounts` (Same‑Tenant + Verbot von `tenant_id`‑Updates).
* **ops_events** wird aus `public` herausgezogen (Schema `internal`) oder via RLS hart verriegelt.
* Entfernt doppelte `set_updated_at`‑Trigger (Tenants/Subscriptions).

> Alle Migrationen sind idempotent und in logischer Reihenfolge. Entscheide dich bei **ops_events** für Variante **A (internal)** oder **B (public + RLS)**.

---

### Ordered migrations (SQL)

#### 0) Optional: `ops_events` absichern (Variante wählen)

**A) In internes Schema verschieben**

```sql
CREATE SCHEMA IF NOT EXISTS internal;
ALTER TABLE IF EXISTS public.ops_events SET SCHEMA internal;
DROP INDEX IF EXISTS internal.idx_ops_events_created;
CREATE INDEX IF NOT EXISTS idx_ops_events_created_at
  ON internal.ops_events (created_at DESC);
```

**B) In `public`, aber mit RLS verriegeln**

```sql
ALTER TABLE public.ops_events ENABLE ROW LEVEL SECURITY;
REVOKE ALL ON TABLE public.ops_events FROM PUBLIC;
DROP INDEX IF EXISTS public.idx_ops_events_created;
CREATE INDEX IF NOT EXISTS idx_ops_events_created_at
  ON public.ops_events (created_at DESC);
```

#### 1) Doppelte `set_updated_at`‑Trigger bereinigen (Tenants/Subscriptions)

```sql
-- Tenants: nur EIN Trigger behalten
DROP TRIGGER IF EXISTS set_updated_at_tenants ON public.tenants;
-- (trg_tenants_updated_at bleibt aktiv)

-- Subscriptions: nur EIN Trigger behalten
DROP TRIGGER IF EXISTS set_updated_at_subscriptions ON public.subscriptions;
-- (trg_subscriptions_updated_at bleibt aktiv)
```

#### 2) RLS: alle alten Policies aufräumen (Zieltabellen)

```sql
DO $$
DECLARE r record;
BEGIN
  FOR r IN
    SELECT policyname, tablename
    FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename IN (
        'appointments','services','staff','customers',
        'customer_notes','customer_tags','customer_accounts',
        'memberships','tenants','audit_logs','invitations',
        'subscriptions','profiles'
      )
  LOOP
    EXECUTE format('DROP POLICY IF EXISTS %I ON public.%I;', r.policyname, r.tablename);
  END LOOP;
END $$;
```

#### 3) RLS: konsolidierte Policies anlegen

```sql
-- Appointments
ALTER TABLE public.appointments ENABLE ROW LEVEL SECURITY;
CREATE POLICY appt_select ON public.appointments FOR SELECT TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
);
CREATE POLICY appt_insert ON public.appointments FOR INSERT TO authenticated
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
);
CREATE POLICY appt_update ON public.appointments FOR UPDATE TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
)
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
);
CREATE POLICY appt_delete ON public.appointments FOR DELETE TO authenticated
USING (
  tenant_id IN (
    SELECT tenant_id FROM public.memberships
    WHERE user_id = auth.uid() AND lower(role) = ANY('{owner,admin}')
  )
);

-- Services
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
CREATE POLICY svc_select ON public.services FOR SELECT TO authenticated
USING (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY svc_insert ON public.services FOR INSERT TO authenticated
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
);
CREATE POLICY svc_update ON public.services FOR UPDATE TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
)
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
);
CREATE POLICY svc_delete ON public.services FOR DELETE TO authenticated
USING (
  tenant_id IN (
    SELECT tenant_id FROM public.memberships
    WHERE user_id = auth.uid() AND lower(role) = ANY('{owner,admin}')
  )
);

-- Staff (Insert mit Limit)
ALTER TABLE public.staff ENABLE ROW LEVEL SECURITY;
CREATE POLICY staff_select ON public.staff FOR SELECT TO authenticated
USING (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY staff_insert ON public.staff FOR INSERT TO authenticated
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
  AND check_staff_limit(tenant_id)
);
CREATE POLICY staff_update ON public.staff FOR UPDATE TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
)
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND tenant_has_access(tenant_id)
);
CREATE POLICY staff_delete ON public.staff FOR DELETE TO authenticated
USING (
  tenant_id IN (
    SELECT tenant_id FROM public.memberships
    WHERE user_id = auth.uid() AND lower(role) = ANY('{owner,admin}')
  )
);

-- Customers
ALTER TABLE public.customers ENABLE ROW LEVEL SECURITY;
CREATE POLICY cust_select ON public.customers FOR SELECT TO authenticated
USING (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY cust_insert ON public.customers FOR INSERT TO authenticated
WITH CHECK (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY cust_update ON public.customers FOR UPDATE TO authenticated
USING (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()))
WITH CHECK (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY cust_delete ON public.customers FOR DELETE TO authenticated
USING (
  tenant_id IN (
    SELECT tenant_id FROM public.memberships
    WHERE user_id = auth.uid() AND lower(role) = ANY('{owner,admin}')
  )
);

-- Customer Notes (Pro Gate über View)
ALTER TABLE public.customer_notes ENABLE ROW LEVEL SECURITY;
CREATE POLICY notes_select ON public.customer_notes FOR SELECT TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND EXISTS (
    SELECT 1 FROM public.active_subscriptions a
    WHERE a.tenant_id = customer_notes.tenant_id AND a.has_access = true
          AND a.tier_key IN ('professional','premium')
  )
);
CREATE POLICY notes_insert ON public.customer_notes FOR INSERT TO authenticated
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND EXISTS (
    SELECT 1 FROM public.active_subscriptions a
    WHERE a.tenant_id = customer_notes.tenant_id AND a.has_access = true
          AND a.tier_key IN ('professional','premium')
  )
);

-- Customer Tags (Pro Gate)
ALTER TABLE public.customer_tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY tags_select ON public.customer_tags FOR SELECT TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND EXISTS (
    SELECT 1 FROM public.active_subscriptions a
    WHERE a.tenant_id = customer_tags.tenant_id AND a.has_access = true
          AND a.tier_key IN ('professional','premium')
  )
);
CREATE POLICY tags_all ON public.customer_tags FOR ALL TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND EXISTS (
    SELECT 1 FROM public.active_subscriptions a
    WHERE a.tenant_id = customer_tags.tenant_id AND a.has_access = true
          AND a.tier_key IN ('professional','premium')
  )
)
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid())
  AND EXISTS (
    SELECT 1 FROM public.active_subscriptions a
    WHERE a.tenant_id = customer_tags.tenant_id AND a.has_access = true
          AND a.tier_key IN ('professional','premium')
  )
);

-- Customer Accounts (Staff+)
ALTER TABLE public.customer_accounts ENABLE ROW LEVEL SECURITY;
CREATE POLICY ca_select ON public.customer_accounts FOR SELECT TO authenticated
USING (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY ca_insert ON public.customer_accounts FOR INSERT TO authenticated
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()
                AND lower(role) = ANY('{owner,admin,staff}'))
);
CREATE POLICY ca_update ON public.customer_accounts FOR UPDATE TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()
                AND lower(role) = ANY('{owner,admin,staff}'))
)
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()
                AND lower(role) = ANY('{owner,admin,staff}'))
);
CREATE POLICY ca_delete ON public.customer_accounts FOR DELETE TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()
                AND lower(role) = ANY('{owner,admin}'))
);

-- Profiles (kein {public})
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE POLICY profiles_select_own ON public.profiles FOR SELECT TO authenticated
USING (id = auth.uid());
CREATE POLICY profiles_update_own ON public.profiles FOR UPDATE TO authenticated
USING (id = auth.uid()) WITH CHECK (id = auth.uid());

-- Invitations (Owner/Admin)
ALTER TABLE public.invitations ENABLE ROW LEVEL SECURITY;
CREATE POLICY inv_select ON public.invitations FOR SELECT TO authenticated
USING (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY inv_insert ON public.invitations FOR INSERT TO authenticated
WITH CHECK (
  tenant_id IN (SELECT tenant_id FROM public.memberships
                WHERE user_id = auth.uid() AND lower(role) = ANY('{owner,admin}'))
  AND created_by = auth.uid()
);
CREATE POLICY inv_delete ON public.invitations FOR DELETE TO authenticated
USING (
  tenant_id IN (SELECT tenant_id FROM public.memberships
                WHERE user_id = auth.uid() AND lower(role) = ANY('{owner,admin}'))
);

-- Memberships (read-only für User; writes via RPC/service_role)
ALTER TABLE public.memberships ENABLE ROW LEVEL SECURITY;
CREATE POLICY mbr_select_own ON public.memberships FOR SELECT TO authenticated
USING (user_id = auth.uid());

-- Tenants
ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;
CREATE POLICY ten_select ON public.tenants FOR SELECT TO authenticated
USING (id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY ten_insert ON public.tenants FOR INSERT TO authenticated
WITH CHECK (auth.uid() IS NOT NULL);
CREATE POLICY ten_update_owner ON public.tenants FOR UPDATE TO authenticated
USING (id IN (SELECT tenant_id FROM public.memberships
              WHERE user_id = auth.uid() AND lower(role) = 'owner'))
WITH CHECK (id IN (SELECT tenant_id FROM public.memberships
                   WHERE user_id = auth.uid() AND lower(role) = 'owner'));

-- Subscriptions: keep service_role full
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
CREATE POLICY subs_select ON public.subscriptions FOR SELECT TO authenticated
USING (tenant_id IN (SELECT tenant_id FROM public.memberships WHERE user_id = auth.uid()));
CREATE POLICY subs_service_all ON public.subscriptions FOR ALL TO service_role
USING (true) WITH CHECK (true);

-- Audit Logs: nur Owner/Admin
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;
CREATE POLICY audit_select_admin ON public.audit_logs FOR SELECT TO authenticated
USING (
  tenant_id IN (
    SELECT tenant_id FROM public.memberships
    WHERE user_id = auth.uid() AND lower(role) = ANY('{owner,admin}')
  )
);
```

#### 4) FKs & Trigger‑Hardening

```sql
-- actor/cancelled_by auf SET NULL
ALTER TABLE public.audit_logs
  DROP CONSTRAINT IF EXISTS audit_logs_actor_id_fkey;
ALTER TABLE public.audit_logs
  ADD CONSTRAINT audit_logs_actor_id_fkey
  FOREIGN KEY (actor_id) REFERENCES public.profiles(id) ON DELETE SET NULL;

ALTER TABLE public.appointments
  DROP CONSTRAINT IF EXISTS appointments_cancelled_by_fkey;
ALTER TABLE public.appointments
  ADD CONSTRAINT appointments_cancelled_by_fkey
  FOREIGN KEY (cancelled_by) REFERENCES public.profiles(id) ON DELETE SET NULL;

-- appointments.customer_id FK + Same‑Tenant‑Enforcement
ALTER TABLE public.appointments
  ADD CONSTRAINT IF NOT EXISTS appointments_customer_id_fkey
  FOREIGN KEY (customer_id) REFERENCES public.customers(id) ON DELETE SET NULL NOT VALID;
ALTER TABLE public.appointments VALIDATE CONSTRAINT appointments_customer_id_fkey;

CREATE OR REPLACE FUNCTION enforce_appt_customer_same_tenant()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.customer_id IS NULL THEN RETURN NEW; END IF;
  IF NOT EXISTS (
    SELECT 1 FROM public.customers c
    WHERE c.id = NEW.customer_id AND c.tenant_id = NEW.tenant_id
  ) THEN
    RAISE EXCEPTION 'appointment.tenant_id must match customers.tenant_id for customer_id=%', NEW.customer_id;
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_appt_same_tenant ON public.appointments;
CREATE TRIGGER trg_appt_same_tenant
  BEFORE INSERT OR UPDATE OF tenant_id, customer_id
  ON public.appointments
  FOR EACH ROW EXECUTE FUNCTION enforce_appt_customer_same_tenant();

-- customer_accounts Hardening
CREATE OR REPLACE FUNCTION ca_enforce_same_tenant()
RETURNS TRIGGER AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM public.customers c
    WHERE c.id = NEW.customer_id AND c.tenant_id = NEW.tenant_id
  ) THEN
    RAISE EXCEPTION 'customer_accounts.tenant_id must match customers.tenant_id';
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_ca_same_tenant ON public.customer_accounts;
CREATE TRIGGER trg_ca_same_tenant
  BEFORE INSERT OR UPDATE OF tenant_id, customer_id
  ON public.customer_accounts
  FOR EACH ROW EXECUTE FUNCTION ca_enforce_same_tenant();

CREATE OR REPLACE FUNCTION prevent_ca_tenant_change()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'UPDATE' AND NEW.tenant_id <> OLD.tenant_id THEN
    RAISE EXCEPTION 'Changing tenant_id is not allowed';
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_ca_prevent_tenant_change ON public.customer_accounts;
CREATE TRIGGER trg_ca_prevent_tenant_change
  BEFORE UPDATE OF tenant_id ON public.customer_accounts
  FOR EACH ROW EXECUTE FUNCTION prevent_ca_tenant_change();
```

#### 5) Appointments — No‑Overlap + Index‑Cleanup

```sql
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- doppelte GiST Indizes entfernen
DROP INDEX IF EXISTS public.idx_appointments_staff_time;
DROP INDEX IF EXISTS public.no_overlap_per_staff;

-- status-sensitiver Exclusion‑Constraint
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'appointments_no_overlap'
  ) THEN
    ALTER TABLE public.appointments
      ADD CONSTRAINT appointments_no_overlap
      EXCLUDE USING gist (
        tenant_id WITH =,
        staff_id  WITH =,
        (CASE WHEN status IN ('SCHEDULED','CONFIRMED','IN_PROGRESS') THEN time_range END) WITH &&
      );
  END IF;
END $$;

-- Abfrageindex by tenant + start_time
DROP INDEX IF EXISTS public.idx_appointments_time;
CREATE INDEX IF NOT EXISTS idx_appointments_tenant_start
  ON public.appointments (tenant_id, start_time DESC);
```

#### 6) Money‑Alignment & Stats‑Trigger

```sql
-- Spalte existiert bereits? Falls nicht, hinzufügen
ALTER TABLE public.appointments
  ADD COLUMN IF NOT EXISTS total_amount_cents INTEGER;

-- Stats‑Trigger neu (verwendet Cents)
CREATE OR REPLACE FUNCTION update_customer_stats()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' OR (TG_OP = 'UPDATE' AND NEW.status = 'COMPLETED' AND OLD.status <> 'COMPLETED') THEN
    UPDATE public.customers
    SET
      visit_count = visit_count + 1,
      last_visit  = COALESCE(CAST(NEW.end_time AS date), CURRENT_DATE),
      total_spent = total_spent + COALESCE(NEW.total_amount_cents,
                                           CEIL(COALESCE(NEW.total_price, 0) * 100)::int)
    WHERE id = NEW.customer_id;
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;
```

---

### Post‑migration checks

```sql
-- 1) RLS Smoke Test
SELECT current_setting('role', true) AS role, auth.uid();
SELECT * FROM public.memberships WHERE user_id = auth.uid();

-- 2) Appointments: Versuch der Doppelbuchung sollte fehlschlagen
-- (zweiter INSERT mit gleicher staff_id/tenant_id und überlappendem time_range)

-- 3) Stats: setze Termin auf COMPLETED und prüfe customers.total_spent/visit_count

-- 4) customer_accounts: versuche inkonsistenten tenant → sollte Exception werfen
```

### Rollback Hinweise

* RLS: alte Policies können aus Git/DB‑History wiederhergestellt werden; alternativ einfach die neuen droppen und alte neu anlegen.
* Exclusion‑Constraint: `ALTER TABLE public.appointments DROP CONSTRAINT appointments_no_overlap;` und ggf. GiST‑Index re‑anlegen.
* Trigger/Functions: `CREATE OR REPLACE FUNCTION` ist reversibel via vorherige Version; bei Bedarf aus Dump.
* `ops_events`: Schema‑Move kann rückgängig gemacht werden mit `ALTER TABLE internal.ops_events SET SCHEMA public;`.

---

### Notes

* Wir nutzen konsequent die View **`active_subscriptions`** für Feature‑Gates (Professional/Premium). Keine direkten JOIN‑Bedingungen in RLS.
* Rollenvergleiche immer via `lower(role)`; fallweise Case‑Mix in Daten ist damit robust.
* `memberships` bleibt für End‑User **read‑only**; alle Schreibpfade über **RPC** oder **service_role**.
